$(document).ready(function() {
    var scope = {
	gridSide: 100, // 100px to a side
	gridSize: 5, // 5x5 
	currentGame: {
	    gid: null,
	    0: null,
	    1: null,
	    2: null,
	    state: function() {
		if (this[0] && this[1] && this[2]) {
		    return [this[0], this[1], this[2]]
			.map(function(idx) {return 1 << idx})
			.reduce(function(a, b) {return a + b})
		}
	    },
	    pendingMove: null
	}
    }; // scope

    
    /* function proposeMove(event) -> `currentGame` update
     * 
     * Handle `onDragEnd` event for `Draggable` instances. Tests for which
     * `.cell` is closest and snaps to it. Updates `currentGame` model for
     * current piece's state.
     */
    function proposeMove(e) {
	var cells = scope.cells,
	    i = cells.length,
	    elem =  this._eventTarget,
	    pieceId = elem.id.slice(-1),
	    targetCell,
	    _tmp;
	
	while (--i > -1) {
	    if (this.hitTest(cells[i], '26%')) {
		targetCell = cells[i];
		
		// Update Model
		_tmp = scope.currentGame[pieceId];
		scope.currentGame[pieceId] =
		    targetCell.getAttribute('idx') | 0;
		scope.currentGame.pendingMove = {
		    piece: pieceId,
		    from: _tmp,
		    to: scope.currentGame[pieceId]
		};

		// Snap to grid
		TweenMax.to(elem, 0.5, {
		    x: $(targetCell).css('left'),
		    y: $(targetCell).css('top'),
		    ease: Power2.easeOut
		}); 
	    }
	}
    }
    
    initializeGameBoard();    
    function initializeGameBoard() {
	buildGrid(scope);
	setPieces(scope);
	createDraggables(proposeMove);
    } // `initializeGameBoard()`

    $('#send').click(function() {
	console.log(JSON.stringify(scope.currentGame.pendingMove));
    });
    
}); // document.ready
    
