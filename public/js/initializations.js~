/* function buildGrid() -> DOM update
 *
 * Find the `#game-board` div and populate it with `.cell` divs.
 *
 * Requires that `config` object be in scope.
 */
function buildGrid(config) {
    for (var i = 0; i < 25; i++) {
	var y = Math.floor(i / 5) * config.gridSide,
	    x = (i * config.gridSide) % (config.gridSize
					 * config.gridSide);
	$('<div/>').css({width: config.gridSide - 1,
			 height: config.gridSide -1,
			 top: y, left: x})
	    .attr({idx: 24 - i,
		   class: 'cell'})
	    .prependTo($('#game-board'));
	config.cells = $('.cell');
    }
}

/* function setPieces() -> DOM update
 * 
 * Create `.player-piece` divs with a css:top and css:left set to
 * 0, the origin being the top left of the `#stage` div.
 *
 * The pieces are moved around with css:transform, and the coordinates
 * are snapped to the css:top and css:left of the nearest `.cell`.
*/
function setPieces(config) {
    for (var i = 0; i < 3; i++) {
	$('<div/>').css({position: "absolute",
			 'z-index': 1,
			 width: config.gridSide - 2,
			 height: config.gridSide - 2,
			 top: 0,
			 left: 0,
			 transform: 'translate(0px, 600px)'})
	    .attr({class: "player-piece",
		   id: "player-" + i})
	    .prependTo($('#stage'));
    }
}

/* function createDraggables(dropFunc) -> DOM update
 * 
 * Find `.player-piece`s and make them draggable. Takes one parameter,
 * dropFunc, which is called when drag finishes.
 * 
 * Note: dropFunc takes one parameter, the event associated, and it
 * binds `this` to the Draggable instance in operation.
 */
function createDraggables(dropFunc) {
    Draggable.create(".player-piece", {
	bounds:$('#stage'),
	edgeResistance:0.65,
	type:"x,y",
	onDragEnd: dropFunc
    });
}
